// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn associate_encryption_config(&self) -> fluent_builders::AssociateEncryptionConfig<C> {
        fluent_builders::AssociateEncryptionConfig::new(self.handle.clone())
    }
    pub fn associate_identity_provider_config(
        &self,
    ) -> fluent_builders::AssociateIdentityProviderConfig<C> {
        fluent_builders::AssociateIdentityProviderConfig::new(self.handle.clone())
    }
    pub fn create_addon(&self) -> fluent_builders::CreateAddon<C> {
        fluent_builders::CreateAddon::new(self.handle.clone())
    }
    pub fn create_cluster(&self) -> fluent_builders::CreateCluster<C> {
        fluent_builders::CreateCluster::new(self.handle.clone())
    }
    pub fn create_fargate_profile(&self) -> fluent_builders::CreateFargateProfile<C> {
        fluent_builders::CreateFargateProfile::new(self.handle.clone())
    }
    pub fn create_nodegroup(&self) -> fluent_builders::CreateNodegroup<C> {
        fluent_builders::CreateNodegroup::new(self.handle.clone())
    }
    pub fn delete_addon(&self) -> fluent_builders::DeleteAddon<C> {
        fluent_builders::DeleteAddon::new(self.handle.clone())
    }
    pub fn delete_cluster(&self) -> fluent_builders::DeleteCluster<C> {
        fluent_builders::DeleteCluster::new(self.handle.clone())
    }
    pub fn delete_fargate_profile(&self) -> fluent_builders::DeleteFargateProfile<C> {
        fluent_builders::DeleteFargateProfile::new(self.handle.clone())
    }
    pub fn delete_nodegroup(&self) -> fluent_builders::DeleteNodegroup<C> {
        fluent_builders::DeleteNodegroup::new(self.handle.clone())
    }
    pub fn describe_addon(&self) -> fluent_builders::DescribeAddon<C> {
        fluent_builders::DescribeAddon::new(self.handle.clone())
    }
    pub fn describe_addon_versions(&self) -> fluent_builders::DescribeAddonVersions<C> {
        fluent_builders::DescribeAddonVersions::new(self.handle.clone())
    }
    pub fn describe_cluster(&self) -> fluent_builders::DescribeCluster<C> {
        fluent_builders::DescribeCluster::new(self.handle.clone())
    }
    pub fn describe_fargate_profile(&self) -> fluent_builders::DescribeFargateProfile<C> {
        fluent_builders::DescribeFargateProfile::new(self.handle.clone())
    }
    pub fn describe_identity_provider_config(
        &self,
    ) -> fluent_builders::DescribeIdentityProviderConfig<C> {
        fluent_builders::DescribeIdentityProviderConfig::new(self.handle.clone())
    }
    pub fn describe_nodegroup(&self) -> fluent_builders::DescribeNodegroup<C> {
        fluent_builders::DescribeNodegroup::new(self.handle.clone())
    }
    pub fn describe_update(&self) -> fluent_builders::DescribeUpdate<C> {
        fluent_builders::DescribeUpdate::new(self.handle.clone())
    }
    pub fn disassociate_identity_provider_config(
        &self,
    ) -> fluent_builders::DisassociateIdentityProviderConfig<C> {
        fluent_builders::DisassociateIdentityProviderConfig::new(self.handle.clone())
    }
    pub fn list_addons(&self) -> fluent_builders::ListAddons<C> {
        fluent_builders::ListAddons::new(self.handle.clone())
    }
    pub fn list_clusters(&self) -> fluent_builders::ListClusters<C> {
        fluent_builders::ListClusters::new(self.handle.clone())
    }
    pub fn list_fargate_profiles(&self) -> fluent_builders::ListFargateProfiles<C> {
        fluent_builders::ListFargateProfiles::new(self.handle.clone())
    }
    pub fn list_identity_provider_configs(
        &self,
    ) -> fluent_builders::ListIdentityProviderConfigs<C> {
        fluent_builders::ListIdentityProviderConfigs::new(self.handle.clone())
    }
    pub fn list_nodegroups(&self) -> fluent_builders::ListNodegroups<C> {
        fluent_builders::ListNodegroups::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn list_updates(&self) -> fluent_builders::ListUpdates<C> {
        fluent_builders::ListUpdates::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_addon(&self) -> fluent_builders::UpdateAddon<C> {
        fluent_builders::UpdateAddon::new(self.handle.clone())
    }
    pub fn update_cluster_config(&self) -> fluent_builders::UpdateClusterConfig<C> {
        fluent_builders::UpdateClusterConfig::new(self.handle.clone())
    }
    pub fn update_cluster_version(&self) -> fluent_builders::UpdateClusterVersion<C> {
        fluent_builders::UpdateClusterVersion::new(self.handle.clone())
    }
    pub fn update_nodegroup_config(&self) -> fluent_builders::UpdateNodegroupConfig<C> {
        fluent_builders::UpdateNodegroupConfig::new(self.handle.clone())
    }
    pub fn update_nodegroup_version(&self) -> fluent_builders::UpdateNodegroupVersion<C> {
        fluent_builders::UpdateNodegroupVersion::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AssociateEncryptionConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_encryption_config_input::Builder,
    }
    impl<C> AssociateEncryptionConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateEncryptionConfigOutput,
            smithy_http::result::SdkError<crate::error::AssociateEncryptionConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the cluster that you are associating with encryption configuration.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The configuration you are using for encryption.</p>
        pub fn encryption_config(mut self, inp: impl Into<crate::model::EncryptionConfig>) -> Self {
            self.inner = self.inner.encryption_config(inp);
            self
        }
        pub fn set_encryption_config(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EncryptionConfig>>,
        ) -> Self {
            self.inner = self.inner.set_encryption_config(input);
            self
        }
        /// <p>The client request token you are using with the encryption configuration.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct AssociateIdentityProviderConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_identity_provider_config_input::Builder,
    }
    impl<C> AssociateIdentityProviderConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateIdentityProviderConfigOutput,
            smithy_http::result::SdkError<crate::error::AssociateIdentityProviderConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the cluster to associate the configuration to.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>An object that represents an OpenID Connect (OIDC) identity provider
        /// configuration.</p>
        pub fn oidc(mut self, input: crate::model::OidcIdentityProviderConfigRequest) -> Self {
            self.inner = self.inner.oidc(input);
            self
        }
        pub fn set_oidc(
            mut self,
            input: std::option::Option<crate::model::OidcIdentityProviderConfigRequest>,
        ) -> Self {
            self.inner = self.inner.set_oidc(input);
            self
        }
        /// <p>The metadata to apply to the configuration to assist with categorization and
        /// organization. Each tag consists of a key and an optional value, both of which you
        /// define.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateAddon<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_addon_input::Builder,
    }
    impl<C> CreateAddon<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAddonOutput,
            smithy_http::result::SdkError<crate::error::CreateAddonError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the cluster to create the add-on for.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The name of the add-on. The name must match one of the names returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html">
        /// <code>ListAddons</code>
        /// </a>.</p>
        pub fn addon_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.addon_name(input);
            self
        }
        pub fn set_addon_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_addon_name(input);
            self
        }
        /// <p>The version of the add-on. The version must match one of the versions returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html">
        /// <code>DescribeAddonVersions</code>
        /// </a>.</p>
        pub fn addon_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.addon_version(input);
            self
        }
        pub fn set_addon_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_addon_version(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an existing IAM role to bind to the add-on's service account. The role must be assigned the IAM permissions required by the add-on. If you don't specify an existing IAM role, then the add-on uses the
        /// permissions assigned to the node IAM role. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html">Amazon EKS node IAM role</a> in the <i>Amazon EKS User Guide</i>.</p>
        /// <note>
        /// <p>To specify an existing IAM role, you must have an IAM OpenID Connect (OIDC) provider created for
        /// your cluster. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html">Enabling
        /// IAM roles for service accounts on your cluster</a> in the
        /// <i>Amazon EKS User Guide</i>.</p>
        /// </note>
        pub fn service_account_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_account_role_arn(input);
            self
        }
        pub fn set_service_account_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_account_role_arn(input);
            self
        }
        /// <p>How to resolve parameter value conflicts when migrating an existing add-on to an Amazon EKS
        /// add-on.</p>
        pub fn resolve_conflicts(mut self, input: crate::model::ResolveConflicts) -> Self {
            self.inner = self.inner.resolve_conflicts(input);
            self
        }
        pub fn set_resolve_conflicts(
            mut self,
            input: std::option::Option<crate::model::ResolveConflicts>,
        ) -> Self {
            self.inner = self.inner.set_resolve_conflicts(input);
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>The metadata to apply to the cluster to assist with categorization and organization.
        /// Each tag consists of a key and an optional value, both of which you define. </p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_cluster_input::Builder,
    }
    impl<C> CreateCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateClusterOutput,
            smithy_http::result::SdkError<crate::error::CreateClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique name to give to your cluster.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The desired Kubernetes version for your cluster. If you don't specify a value here,
        /// the latest version available in Amazon EKS is used.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role that provides permissions for the Kubernetes control
        /// plane to make calls to AWS API operations on your behalf. For more information, see
        /// <a href="https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html">Amazon EKS
        /// Service IAM Role</a> in the <i>
        /// <i>Amazon EKS User Guide</i>
        /// </i>.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>The VPC configuration used by the cluster control plane. Amazon EKS VPC resources have
        /// specific requirements to work properly with Kubernetes. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html">Cluster VPC
        /// Considerations</a> and <a href="https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html">Cluster Security Group Considerations</a> in the
        /// <i>Amazon EKS User Guide</i>. You must specify at least two subnets. You can specify up to five
        /// security groups, but we recommend that you use a dedicated security group for your
        /// cluster control plane.</p>
        pub fn resources_vpc_config(mut self, input: crate::model::VpcConfigRequest) -> Self {
            self.inner = self.inner.resources_vpc_config(input);
            self
        }
        pub fn set_resources_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfigRequest>,
        ) -> Self {
            self.inner = self.inner.set_resources_vpc_config(input);
            self
        }
        /// <p>The Kubernetes network configuration for the cluster.</p>
        pub fn kubernetes_network_config(
            mut self,
            input: crate::model::KubernetesNetworkConfigRequest,
        ) -> Self {
            self.inner = self.inner.kubernetes_network_config(input);
            self
        }
        pub fn set_kubernetes_network_config(
            mut self,
            input: std::option::Option<crate::model::KubernetesNetworkConfigRequest>,
        ) -> Self {
            self.inner = self.inner.set_kubernetes_network_config(input);
            self
        }
        /// <p>Enable or disable exporting the Kubernetes control plane logs for your cluster to
        /// CloudWatch Logs. By default, cluster control plane logs aren't exported to CloudWatch Logs. For more
        /// information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html">Amazon EKS Cluster Control Plane Logs</a> in the
        /// <i>
        /// <i>Amazon EKS User Guide</i>
        /// </i>.</p>
        /// <note>
        /// <p>CloudWatch Logs ingestion, archive storage, and data scanning rates apply to exported
        /// control plane logs. For more information, see <a href="http://aws.amazon.com/cloudwatch/pricing/">Amazon CloudWatch Pricing</a>.</p>
        /// </note>
        pub fn logging(mut self, input: crate::model::Logging) -> Self {
            self.inner = self.inner.logging(input);
            self
        }
        pub fn set_logging(mut self, input: std::option::Option<crate::model::Logging>) -> Self {
            self.inner = self.inner.set_logging(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>The metadata to apply to the cluster to assist with categorization and organization.
        /// Each tag consists of a key and an optional value, both of which you define.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The encryption configuration for the cluster.</p>
        pub fn encryption_config(mut self, inp: impl Into<crate::model::EncryptionConfig>) -> Self {
            self.inner = self.inner.encryption_config(inp);
            self
        }
        pub fn set_encryption_config(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EncryptionConfig>>,
        ) -> Self {
            self.inner = self.inner.set_encryption_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFargateProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_fargate_profile_input::Builder,
    }
    impl<C> CreateFargateProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFargateProfileOutput,
            smithy_http::result::SdkError<crate::error::CreateFargateProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Fargate profile.</p>
        pub fn fargate_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fargate_profile_name(input);
            self
        }
        pub fn set_fargate_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_fargate_profile_name(input);
            self
        }
        /// <p>The name of the Amazon EKS cluster to apply the Fargate profile to.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the pod execution role to use for pods that match the selectors in
        /// the Fargate profile. The pod execution role allows Fargate infrastructure to register with
        /// your cluster as a node, and it provides read access to Amazon ECR image repositories. For
        /// more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/pod-execution-role.html">Pod Execution Role</a> in the
        /// <i>Amazon EKS User Guide</i>.</p>
        pub fn pod_execution_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pod_execution_role_arn(input);
            self
        }
        pub fn set_pod_execution_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pod_execution_role_arn(input);
            self
        }
        /// <p>The IDs of subnets to launch your pods into. At this time, pods running on Fargate are
        /// not assigned public IP addresses, so only private subnets (with no direct route to an
        /// Internet Gateway) are accepted for this parameter.</p>
        pub fn subnets(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnets(inp);
            self
        }
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnets(input);
            self
        }
        /// <p>The selectors to match for pods to use this Fargate profile. Each selector must have an
        /// associated namespace. Optionally, you can also specify labels for a namespace. You may
        /// specify up to five selectors in a Fargate profile.</p>
        pub fn selectors(mut self, inp: impl Into<crate::model::FargateProfileSelector>) -> Self {
            self.inner = self.inner.selectors(inp);
            self
        }
        pub fn set_selectors(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::FargateProfileSelector>>,
        ) -> Self {
            self.inner = self.inner.set_selectors(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>The metadata to apply to the Fargate profile to assist with categorization and
        /// organization. Each tag consists of a key and an optional value, both of which you
        /// define. Fargate profile tags do not propagate to any other resources associated with the
        /// Fargate profile, such as the pods that are scheduled with it.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateNodegroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_nodegroup_input::Builder,
    }
    impl<C> CreateNodegroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateNodegroupOutput,
            smithy_http::result::SdkError<crate::error::CreateNodegroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the cluster to create the node group in.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The unique name to give your node group.</p>
        pub fn nodegroup_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.nodegroup_name(input);
            self
        }
        pub fn set_nodegroup_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_nodegroup_name(input);
            self
        }
        /// <p>The scaling configuration details for the Auto Scaling group that is created for your
        /// node group.</p>
        pub fn scaling_config(mut self, input: crate::model::NodegroupScalingConfig) -> Self {
            self.inner = self.inner.scaling_config(input);
            self
        }
        pub fn set_scaling_config(
            mut self,
            input: std::option::Option<crate::model::NodegroupScalingConfig>,
        ) -> Self {
            self.inner = self.inner.set_scaling_config(input);
            self
        }
        /// <p>The root device disk size (in GiB) for your node group instances. The default disk
        /// size is 20 GiB. If you specify <code>launchTemplate</code>, then don't specify  <code>diskSize</code>,
        /// or the node group  deployment will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the Amazon EKS User Guide.</p>
        pub fn disk_size(mut self, input: i32) -> Self {
            self.inner = self.inner.disk_size(input);
            self
        }
        pub fn set_disk_size(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_disk_size(input);
            self
        }
        /// <p>The subnets to use for the Auto Scaling group that is created for your node group.
        /// If you specify <code>launchTemplate</code>, then don't specify  <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateNetworkInterface.html">
        /// <code>SubnetId</code>
        /// </a> in your launch template, or the node group
        /// deployment will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the Amazon EKS User Guide.</p>
        pub fn subnets(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnets(inp);
            self
        }
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_subnets(input);
            self
        }
        /// <p>Specify the instance types for a node group. If you specify a GPU instance type, be
        /// sure to specify <code>AL2_x86_64_GPU</code> with the <code>amiType</code> parameter. If
        /// you specify <code>launchTemplate</code>, then you can specify zero or one instance type
        /// in your launch template <i>or</i> you can specify 0-20 instance types for
        /// <code>instanceTypes</code>. If however, you specify an instance type in your launch
        /// template <i>and</i> specify any <code>instanceTypes</code>, the node group
        /// deployment will fail. If you don't specify an instance type in a launch template or for
        /// <code>instanceTypes</code>, then <code>t3.medium</code> is used, by default. If you
        /// specify <code>Spot</code> for <code>capacityType</code>, then we recommend specifying
        /// multiple values for <code>instanceTypes</code>. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html#managed-node-group-capacity-types">Managed node group capacity types</a> and <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in
        /// the <i>Amazon EKS User Guide</i>.</p>
        pub fn instance_types(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_types(inp);
            self
        }
        pub fn set_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_types(input);
            self
        }
        /// <p>The AMI type for your node group. GPU instance types should use the
        /// <code>AL2_x86_64_GPU</code> AMI type. Non-GPU instances should use the
        /// <code>AL2_x86_64</code> AMI type. Arm instances should use the
        /// <code>AL2_ARM_64</code> AMI type. All types use the Amazon EKS optimized Amazon Linux 2 AMI.
        /// If you specify <code>launchTemplate</code>, and your launch template uses a custom AMI, then don't specify <code>amiType</code>,
        /// or the node group  deployment will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the Amazon EKS User Guide.</p>
        pub fn ami_type(mut self, input: crate::model::AmiTypes) -> Self {
            self.inner = self.inner.ami_type(input);
            self
        }
        pub fn set_ami_type(mut self, input: std::option::Option<crate::model::AmiTypes>) -> Self {
            self.inner = self.inner.set_ami_type(input);
            self
        }
        /// <p>The remote access (SSH) configuration to use with your node group. If you specify <code>launchTemplate</code>,
        /// then don't specify  <code>remoteAccess</code>, or the node group  deployment
        /// will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the Amazon EKS User Guide.</p>
        pub fn remote_access(mut self, input: crate::model::RemoteAccessConfig) -> Self {
            self.inner = self.inner.remote_access(input);
            self
        }
        pub fn set_remote_access(
            mut self,
            input: std::option::Option<crate::model::RemoteAccessConfig>,
        ) -> Self {
            self.inner = self.inner.set_remote_access(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role to associate with your node group. The Amazon EKS worker
        /// node <code>kubelet</code> daemon makes calls to AWS APIs on your behalf. Nodes receive
        /// permissions for these API calls through an IAM instance profile and associated
        /// policies. Before you can launch nodes and register them into a cluster, you must create
        /// an IAM role for those nodes to use when they are launched. For more information, see
        /// <a href="https://docs.aws.amazon.com/eks/latest/userguide/worker_node_IAM_role.html">Amazon EKS node IAM role</a> in the <i>
        /// <i>Amazon EKS User Guide</i>
        /// </i>.
        /// If you specify <code>launchTemplate</code>, then don't specify  <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IamInstanceProfile.html">
        /// <code>IamInstanceProfile</code>
        /// </a> in your launch template,
        /// or the node group  deployment will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the Amazon EKS User Guide.</p>
        pub fn node_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.node_role(input);
            self
        }
        pub fn set_node_role(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_node_role(input);
            self
        }
        /// <p>The Kubernetes labels to be applied to the nodes in the node group when they are
        /// created.</p>
        pub fn labels(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.labels(k, v);
            self
        }
        pub fn set_labels(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_labels(input);
            self
        }
        /// <p>The Kubernetes taints to be applied to the nodes in the node group.</p>
        pub fn taints(mut self, inp: impl Into<crate::model::Taint>) -> Self {
            self.inner = self.inner.taints(inp);
            self
        }
        pub fn set_taints(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Taint>>,
        ) -> Self {
            self.inner = self.inner.set_taints(input);
            self
        }
        /// <p>The metadata to apply to the node group to assist with categorization and
        /// organization. Each tag consists of a key and an optional value, both of which you
        /// define. Node group tags do not propagate to any other resources associated with the node
        /// group, such as the Amazon EC2 instances or subnets.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>An object representing a node group's launch template specification. If specified,
        /// then do not specify <code>instanceTypes</code>, <code>diskSize</code>, or
        /// <code>remoteAccess</code> and make sure that the launch template meets the
        /// requirements in <code>launchTemplateSpecification</code>.</p>
        pub fn launch_template(mut self, input: crate::model::LaunchTemplateSpecification) -> Self {
            self.inner = self.inner.launch_template(input);
            self
        }
        pub fn set_launch_template(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateSpecification>,
        ) -> Self {
            self.inner = self.inner.set_launch_template(input);
            self
        }
        pub fn update_config(mut self, input: crate::model::NodegroupUpdateConfig) -> Self {
            self.inner = self.inner.update_config(input);
            self
        }
        pub fn set_update_config(
            mut self,
            input: std::option::Option<crate::model::NodegroupUpdateConfig>,
        ) -> Self {
            self.inner = self.inner.set_update_config(input);
            self
        }
        /// <p>The capacity type for your node group.</p>
        pub fn capacity_type(mut self, input: crate::model::CapacityTypes) -> Self {
            self.inner = self.inner.capacity_type(input);
            self
        }
        pub fn set_capacity_type(
            mut self,
            input: std::option::Option<crate::model::CapacityTypes>,
        ) -> Self {
            self.inner = self.inner.set_capacity_type(input);
            self
        }
        /// <p>The Kubernetes version to use for your managed nodes. By default, the Kubernetes
        /// version of the cluster is used, and this is the only accepted specified value.
        /// If you specify <code>launchTemplate</code>, and your launch template uses a custom AMI, then don't specify  <code>version</code>,
        /// or the node group  deployment will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the Amazon EKS User Guide.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
        /// <p>The AMI version of the Amazon EKS optimized AMI to use with your node group. By default,
        /// the latest available AMI version for the node group's current Kubernetes version is
        /// used. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html">Amazon EKS
        /// optimized Amazon Linux 2 AMI versions</a> in the <i>Amazon EKS User Guide</i>. If you specify <code>launchTemplate</code>,
        /// and your launch template uses a custom AMI, then don't specify  <code>releaseVersion</code>, or the node group
        /// deployment will fail. For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the Amazon EKS User Guide.</p>
        pub fn release_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.release_version(input);
            self
        }
        pub fn set_release_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_release_version(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAddon<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_addon_input::Builder,
    }
    impl<C> DeleteAddon<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAddonOutput,
            smithy_http::result::SdkError<crate::error::DeleteAddonError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the cluster to delete the add-on from.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The name of the add-on. The name must match one of the names returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html">
        /// <code>ListAddons</code>
        /// </a>.</p>
        pub fn addon_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.addon_name(input);
            self
        }
        pub fn set_addon_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_addon_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_cluster_input::Builder,
    }
    impl<C> DeleteCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteClusterOutput,
            smithy_http::result::SdkError<crate::error::DeleteClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the cluster to delete.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFargateProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_fargate_profile_input::Builder,
    }
    impl<C> DeleteFargateProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFargateProfileOutput,
            smithy_http::result::SdkError<crate::error::DeleteFargateProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon EKS cluster associated with the Fargate profile to delete.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The name of the Fargate profile to delete.</p>
        pub fn fargate_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fargate_profile_name(input);
            self
        }
        pub fn set_fargate_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_fargate_profile_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteNodegroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_nodegroup_input::Builder,
    }
    impl<C> DeleteNodegroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteNodegroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteNodegroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon EKS cluster that is associated with your node group.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The name of the node group to delete.</p>
        pub fn nodegroup_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.nodegroup_name(input);
            self
        }
        pub fn set_nodegroup_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_nodegroup_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAddon<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_addon_input::Builder,
    }
    impl<C> DescribeAddon<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAddonOutput,
            smithy_http::result::SdkError<crate::error::DescribeAddonError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the cluster.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The name of the add-on. The name must match one of the names returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html">
        /// <code>ListAddons</code>
        /// </a>.</p>
        pub fn addon_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.addon_name(input);
            self
        }
        pub fn set_addon_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_addon_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAddonVersions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_addon_versions_input::Builder,
    }
    impl<C> DescribeAddonVersions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAddonVersionsOutput,
            smithy_http::result::SdkError<crate::error::DescribeAddonVersionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Kubernetes versions that the add-on can be used with.</p>
        pub fn kubernetes_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kubernetes_version(input);
            self
        }
        pub fn set_kubernetes_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_kubernetes_version(input);
            self
        }
        /// <p>The maximum number of results to return.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a previous paginated
        /// <code>DescribeAddonVersionsRequest</code> where <code>maxResults</code> was used and
        /// the results exceeded the value of that parameter. Pagination continues from the end of
        /// the previous results that returned the <code>nextToken</code> value.</p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that is used only to
        /// retrieve the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The name of the add-on. The name must match one of the names returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html">
        /// <code>ListAddons</code>
        /// </a>.</p>
        pub fn addon_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.addon_name(input);
            self
        }
        pub fn set_addon_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_addon_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeCluster<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_cluster_input::Builder,
    }
    impl<C> DescribeCluster<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeClusterOutput,
            smithy_http::result::SdkError<crate::error::DescribeClusterError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the cluster to describe.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFargateProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_fargate_profile_input::Builder,
    }
    impl<C> DescribeFargateProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFargateProfileOutput,
            smithy_http::result::SdkError<crate::error::DescribeFargateProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon EKS cluster associated with the Fargate profile.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The name of the Fargate profile to describe.</p>
        pub fn fargate_profile_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.fargate_profile_name(input);
            self
        }
        pub fn set_fargate_profile_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_fargate_profile_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeIdentityProviderConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_identity_provider_config_input::Builder,
    }
    impl<C> DescribeIdentityProviderConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeIdentityProviderConfigOutput,
            smithy_http::result::SdkError<crate::error::DescribeIdentityProviderConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The cluster name that the identity provider configuration is associated to.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>An object that represents an identity provider configuration.</p>
        pub fn identity_provider_config(
            mut self,
            input: crate::model::IdentityProviderConfig,
        ) -> Self {
            self.inner = self.inner.identity_provider_config(input);
            self
        }
        pub fn set_identity_provider_config(
            mut self,
            input: std::option::Option<crate::model::IdentityProviderConfig>,
        ) -> Self {
            self.inner = self.inner.set_identity_provider_config(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeNodegroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_nodegroup_input::Builder,
    }
    impl<C> DescribeNodegroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeNodegroupOutput,
            smithy_http::result::SdkError<crate::error::DescribeNodegroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon EKS cluster associated with the node group.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The name of the node group to describe.</p>
        pub fn nodegroup_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.nodegroup_name(input);
            self
        }
        pub fn set_nodegroup_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_nodegroup_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeUpdate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_update_input::Builder,
    }
    impl<C> DescribeUpdate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeUpdateOutput,
            smithy_http::result::SdkError<crate::error::DescribeUpdateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon EKS cluster associated with the update.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The ID of the update to describe.</p>
        pub fn update_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.update_id(input);
            self
        }
        pub fn set_update_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_update_id(input);
            self
        }
        /// <p>The name of the Amazon EKS node group associated with the update.</p>
        pub fn nodegroup_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.nodegroup_name(input);
            self
        }
        pub fn set_nodegroup_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_nodegroup_name(input);
            self
        }
        /// <p>The name of the add-on. The name must match one of the names returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html">
        /// <code>ListAddons</code>
        /// </a>.</p>
        pub fn addon_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.addon_name(input);
            self
        }
        pub fn set_addon_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_addon_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateIdentityProviderConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_identity_provider_config_input::Builder,
    }
    impl<C> DisassociateIdentityProviderConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateIdentityProviderConfigOutput,
            smithy_http::result::SdkError<crate::error::DisassociateIdentityProviderConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the cluster to disassociate an identity provider from.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>An object that represents an identity provider configuration.</p>
        pub fn identity_provider_config(
            mut self,
            input: crate::model::IdentityProviderConfig,
        ) -> Self {
            self.inner = self.inner.identity_provider_config(input);
            self
        }
        pub fn set_identity_provider_config(
            mut self,
            input: std::option::Option<crate::model::IdentityProviderConfig>,
        ) -> Self {
            self.inner = self.inner.set_identity_provider_config(input);
            self
        }
        /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAddons<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_addons_input::Builder,
    }
    impl<C> ListAddons<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAddonsOutput,
            smithy_http::result::SdkError<crate::error::ListAddonsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the cluster.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The maximum number of add-on results returned by <code>ListAddonsRequest</code> in
        /// paginated output. When you use this parameter, <code>ListAddonsRequest</code> returns
        /// only <code>maxResults</code> results in a single page along with a
        /// <code>nextToken</code> response element. You can see the remaining results of the
        /// initial request by sending another <code>ListAddonsRequest</code> request with the
        /// returned <code>nextToken</code> value. This value can be between 1 and
        /// 100. If you don't use this parameter, <code>ListAddonsRequest</code>
        /// returns up to 100 results and a <code>nextToken</code> value, if
        /// applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a previous paginated
        /// <code>ListAddonsRequest</code> where <code>maxResults</code> was used and the
        /// results exceeded the value of that parameter. Pagination continues from the end of the
        /// previous results that returned the <code>nextToken</code> value.</p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that is used only to
        /// retrieve the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListClusters<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_clusters_input::Builder,
    }
    impl<C> ListClusters<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListClustersOutput,
            smithy_http::result::SdkError<crate::error::ListClustersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of cluster results returned by <code>ListClusters</code> in
        /// paginated output. When you use this parameter, <code>ListClusters</code> returns only
        /// <code>maxResults</code> results in a single page along with a <code>nextToken</code>
        /// response element. You can see the remaining results of the initial request by sending
        /// another <code>ListClusters</code> request with the returned <code>nextToken</code>
        /// value. This value can be between 1 and 100. If you don't
        /// use this parameter, <code>ListClusters</code> returns up to 100
        /// results and a <code>nextToken</code> value if applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a previous paginated
        /// <code>ListClusters</code> request where <code>maxResults</code> was used and the
        /// results exceeded the value of that parameter. Pagination continues from the end of the
        /// previous results that returned the <code>nextToken</code> value.</p>
        /// <note>
        /// <p>This token should be treated as an opaque identifier that is used only to
        /// retrieve the next items in a list and not for other programmatic purposes.</p>
        /// </note>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListFargateProfiles<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_fargate_profiles_input::Builder,
    }
    impl<C> ListFargateProfiles<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListFargateProfilesOutput,
            smithy_http::result::SdkError<crate::error::ListFargateProfilesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon EKS cluster that you would like to listFargate profiles in.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The maximum number of Fargate profile results returned by
        /// <code>ListFargateProfiles</code> in paginated output. When you use this parameter,
        /// <code>ListFargateProfiles</code> returns only <code>maxResults</code> results in a
        /// single page along with a <code>nextToken</code> response element. You can see the
        /// remaining results of the initial request by sending another
        /// <code>ListFargateProfiles</code> request with the returned <code>nextToken</code>
        /// value. This value can be between 1 and 100. If you don't
        /// use this parameter, <code>ListFargateProfiles</code> returns up to 100
        /// results and a <code>nextToken</code> value if applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a previous paginated
        /// <code>ListFargateProfiles</code> request where <code>maxResults</code> was used and
        /// the results exceeded the value of that parameter. Pagination continues from the end of
        /// the previous results that returned the <code>nextToken</code> value.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListIdentityProviderConfigs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_identity_provider_configs_input::Builder,
    }
    impl<C> ListIdentityProviderConfigs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListIdentityProviderConfigsOutput,
            smithy_http::result::SdkError<crate::error::ListIdentityProviderConfigsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The cluster name that you want to list identity provider configurations for.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The maximum number of identity provider configurations returned by
        /// <code>ListIdentityProviderConfigs</code> in paginated output. When you use this
        /// parameter, <code>ListIdentityProviderConfigs</code> returns only <code>maxResults</code>
        /// results in a single page along with a <code>nextToken</code> response element. You can
        /// see the remaining results of the initial request by sending another
        /// <code>ListIdentityProviderConfigs</code> request with the returned
        /// <code>nextToken</code> value. This value can be between 1 and
        /// 100. If you don't use this parameter,
        /// <code>ListIdentityProviderConfigs</code> returns up to 100 results
        /// and a <code>nextToken</code> value, if applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a previous paginated
        /// <code>IdentityProviderConfigsRequest</code> where <code>maxResults</code> was used
        /// and the results exceeded the value of that parameter. Pagination continues from the end
        /// of the previous results that returned the <code>nextToken</code> value.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListNodegroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_nodegroups_input::Builder,
    }
    impl<C> ListNodegroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListNodegroupsOutput,
            smithy_http::result::SdkError<crate::error::ListNodegroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon EKS cluster that you would like to list node groups in.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The maximum number of node group results returned by <code>ListNodegroups</code> in
        /// paginated output. When you use this parameter, <code>ListNodegroups</code> returns only
        /// <code>maxResults</code> results in a single page along with a <code>nextToken</code>
        /// response element. You can see the remaining results of the initial request by sending
        /// another <code>ListNodegroups</code> request with the returned <code>nextToken</code>
        /// value. This value can be between 1 and 100. If you don't
        /// use this parameter, <code>ListNodegroups</code> returns up to 100
        /// results and a <code>nextToken</code> value if applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a previous paginated
        /// <code>ListNodegroups</code> request where <code>maxResults</code> was used and the
        /// results exceeded the value of that parameter. Pagination continues from the end of the
        /// previous results that returned the <code>nextToken</code> value.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the
        /// supported resources are Amazon EKS clusters and managed node groups.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListUpdates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_updates_input::Builder,
    }
    impl<C> ListUpdates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListUpdatesOutput,
            smithy_http::result::SdkError<crate::error::ListUpdatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon EKS cluster to list updates for.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The name of the Amazon EKS managed node group to list updates for.</p>
        pub fn nodegroup_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.nodegroup_name(input);
            self
        }
        pub fn set_nodegroup_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_nodegroup_name(input);
            self
        }
        /// <p>The names of the installed add-ons that have available updates.</p>
        pub fn addon_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.addon_name(input);
            self
        }
        pub fn set_addon_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_addon_name(input);
            self
        }
        /// <p>The <code>nextToken</code> value returned from a previous paginated
        /// <code>ListUpdates</code> request where <code>maxResults</code> was used and the
        /// results exceeded the value of that parameter. Pagination continues from the end of the
        /// previous results that returned the <code>nextToken</code> value.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of update results returned by <code>ListUpdates</code> in paginated
        /// output. When you use this parameter, <code>ListUpdates</code> returns only
        /// <code>maxResults</code> results in a single page along with a <code>nextToken</code>
        /// response element. You can see the remaining results of the initial request by sending
        /// another <code>ListUpdates</code> request with the returned <code>nextToken</code> value.
        /// This value can be between 1 and 100. If you don't use this
        /// parameter, <code>ListUpdates</code> returns up to 100 results and a
        /// <code>nextToken</code> value if applicable.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource to which to add tags. Currently, the supported resources
        /// are Amazon EKS clusters and managed node groups.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The tags to add to the resource. A tag is an array of key-value pairs.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource from which to delete tags. Currently, the supported
        /// resources are Amazon EKS clusters and managed node groups.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The keys of the tags to be removed.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateAddon<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_addon_input::Builder,
    }
    impl<C> UpdateAddon<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateAddonOutput,
            smithy_http::result::SdkError<crate::error::UpdateAddonError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the cluster.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The name of the add-on. The name must match one of the names returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html">
        /// <code>ListAddons</code>
        /// </a>.</p>
        pub fn addon_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.addon_name(input);
            self
        }
        pub fn set_addon_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_addon_name(input);
            self
        }
        /// <p>The version of the add-on. The version must match one of the versions returned by <a href="https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html">
        /// <code>DescribeAddonVersions</code>
        /// </a>.</p>
        pub fn addon_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.addon_version(input);
            self
        }
        pub fn set_addon_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_addon_version(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of an existing IAM role to bind to the add-on's service account. The role must be assigned the IAM permissions required by the add-on. If you don't specify an existing IAM role, then the add-on uses the
        /// permissions assigned to the node IAM role. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html">Amazon EKS node IAM role</a> in the <i>Amazon EKS User Guide</i>.</p>
        /// <note>
        /// <p>To specify an existing IAM role, you must have an IAM OpenID Connect (OIDC) provider created for
        /// your cluster. For more information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html">Enabling
        /// IAM roles for service accounts on your cluster</a> in the
        /// <i>Amazon EKS User Guide</i>.</p>
        /// </note>
        pub fn service_account_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_account_role_arn(input);
            self
        }
        pub fn set_service_account_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_account_role_arn(input);
            self
        }
        /// <p>How to resolve parameter value conflicts when applying the new version of the add-on
        /// to the cluster.</p>
        pub fn resolve_conflicts(mut self, input: crate::model::ResolveConflicts) -> Self {
            self.inner = self.inner.resolve_conflicts(input);
            self
        }
        pub fn set_resolve_conflicts(
            mut self,
            input: std::option::Option<crate::model::ResolveConflicts>,
        ) -> Self {
            self.inner = self.inner.set_resolve_conflicts(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateClusterConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_cluster_config_input::Builder,
    }
    impl<C> UpdateClusterConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateClusterConfigOutput,
            smithy_http::result::SdkError<crate::error::UpdateClusterConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon EKS cluster to update.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>An object representing the VPC configuration to use for an Amazon EKS cluster.</p>
        pub fn resources_vpc_config(mut self, input: crate::model::VpcConfigRequest) -> Self {
            self.inner = self.inner.resources_vpc_config(input);
            self
        }
        pub fn set_resources_vpc_config(
            mut self,
            input: std::option::Option<crate::model::VpcConfigRequest>,
        ) -> Self {
            self.inner = self.inner.set_resources_vpc_config(input);
            self
        }
        /// <p>Enable or disable exporting the Kubernetes control plane logs for your cluster to
        /// CloudWatch Logs. By default, cluster control plane logs aren't exported to CloudWatch Logs. For more
        /// information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html">Amazon EKS Cluster Control Plane Logs</a> in the
        /// <i>
        /// <i>Amazon EKS User Guide</i>
        /// </i>.</p>
        /// <note>
        /// <p>CloudWatch Logs ingestion, archive storage, and data scanning rates apply to exported
        /// control plane logs. For more information, see <a href="http://aws.amazon.com/cloudwatch/pricing/">Amazon CloudWatch Pricing</a>.</p>
        /// </note>
        pub fn logging(mut self, input: crate::model::Logging) -> Self {
            self.inner = self.inner.logging(input);
            self
        }
        pub fn set_logging(mut self, input: std::option::Option<crate::model::Logging>) -> Self {
            self.inner = self.inner.set_logging(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateClusterVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_cluster_version_input::Builder,
    }
    impl<C> UpdateClusterVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateClusterVersionOutput,
            smithy_http::result::SdkError<crate::error::UpdateClusterVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon EKS cluster to update.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The desired Kubernetes version following a successful update.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateNodegroupConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_nodegroup_config_input::Builder,
    }
    impl<C> UpdateNodegroupConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateNodegroupConfigOutput,
            smithy_http::result::SdkError<crate::error::UpdateNodegroupConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon EKS cluster that the managed node group resides in.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The name of the managed node group to update.</p>
        pub fn nodegroup_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.nodegroup_name(input);
            self
        }
        pub fn set_nodegroup_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_nodegroup_name(input);
            self
        }
        /// <p>The Kubernetes labels to be applied to the nodes in the node group after the
        /// update.</p>
        pub fn labels(mut self, input: crate::model::UpdateLabelsPayload) -> Self {
            self.inner = self.inner.labels(input);
            self
        }
        pub fn set_labels(
            mut self,
            input: std::option::Option<crate::model::UpdateLabelsPayload>,
        ) -> Self {
            self.inner = self.inner.set_labels(input);
            self
        }
        /// <p>The Kubernetes taints to be applied to the nodes in the node group after the
        /// update.</p>
        pub fn taints(mut self, input: crate::model::UpdateTaintsPayload) -> Self {
            self.inner = self.inner.taints(input);
            self
        }
        pub fn set_taints(
            mut self,
            input: std::option::Option<crate::model::UpdateTaintsPayload>,
        ) -> Self {
            self.inner = self.inner.set_taints(input);
            self
        }
        /// <p>The scaling configuration details for the Auto Scaling group after the update.</p>
        pub fn scaling_config(mut self, input: crate::model::NodegroupScalingConfig) -> Self {
            self.inner = self.inner.scaling_config(input);
            self
        }
        pub fn set_scaling_config(
            mut self,
            input: std::option::Option<crate::model::NodegroupScalingConfig>,
        ) -> Self {
            self.inner = self.inner.set_scaling_config(input);
            self
        }
        pub fn update_config(mut self, input: crate::model::NodegroupUpdateConfig) -> Self {
            self.inner = self.inner.update_config(input);
            self
        }
        pub fn set_update_config(
            mut self,
            input: std::option::Option<crate::model::NodegroupUpdateConfig>,
        ) -> Self {
            self.inner = self.inner.set_update_config(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateNodegroupVersion<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_nodegroup_version_input::Builder,
    }
    impl<C> UpdateNodegroupVersion<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateNodegroupVersionOutput,
            smithy_http::result::SdkError<crate::error::UpdateNodegroupVersionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the Amazon EKS cluster that is associated with the managed node group to
        /// update.</p>
        pub fn cluster_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.cluster_name(input);
            self
        }
        pub fn set_cluster_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_cluster_name(input);
            self
        }
        /// <p>The name of the managed node group to update.</p>
        pub fn nodegroup_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.nodegroup_name(input);
            self
        }
        pub fn set_nodegroup_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_nodegroup_name(input);
            self
        }
        /// <p>The Kubernetes version to update to. If no version is specified, then the Kubernetes
        /// version of the node group does not change. You can specify the Kubernetes version of the
        /// cluster to update the node group to the latest AMI version of the cluster's Kubernetes
        /// version. If you specify <code>launchTemplate</code>, and your launch template uses a custom AMI, then don't specify
        /// <code>version</code>, or the node group  update will fail.
        /// For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the Amazon EKS User Guide.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version(input);
            self
        }
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version(input);
            self
        }
        /// <p>The AMI version of the Amazon EKS optimized AMI to use for the update. By default, the
        /// latest available AMI version for the node group's Kubernetes version is used. For more
        /// information, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html">Amazon EKS optimized Amazon Linux 2 AMI versions </a> in the
        /// <i>Amazon EKS User Guide</i>. If you specify <code>launchTemplate</code>, and your launch template uses a custom AMI, then don't specify
        /// <code>releaseVersion</code>, or the node group  update will fail.
        /// For more information about using launch templates with Amazon EKS, see <a href="https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html">Launch template support</a> in the Amazon EKS User Guide.</p>
        pub fn release_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.release_version(input);
            self
        }
        pub fn set_release_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_release_version(input);
            self
        }
        /// <p>An object representing a node group's launch template specification. You can only
        /// update a node group using a launch template if the node group was originally deployed
        /// with a launch template.</p>
        pub fn launch_template(mut self, input: crate::model::LaunchTemplateSpecification) -> Self {
            self.inner = self.inner.launch_template(input);
            self
        }
        pub fn set_launch_template(
            mut self,
            input: std::option::Option<crate::model::LaunchTemplateSpecification>,
        ) -> Self {
            self.inner = self.inner.set_launch_template(input);
            self
        }
        /// <p>Force the update if the existing node group's pods are unable to be drained due to a
        /// pod disruption budget issue. If an update fails because pods could not be drained, you
        /// can force the update after it fails to terminate the old node whether or not any pods
        /// are running on the node.</p>
        pub fn force(mut self, input: bool) -> Self {
            self.inner = self.inner.force(input);
            self
        }
        pub fn set_force(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force(input);
            self
        }
        /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
        /// request.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
}
